{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PyPeakify","text":"<p>PyPeakify is a Python package that provides a simple way to perform peak deconvolutions of various spectra.</p>"},{"location":"#installation","title":"Installation","text":"<p>PyPeakify can be installed using pip:</p> <pre><code>pip install pypeakify\n</code></pre> <p>Alternatively, PyPeakify is available on GitHub and can be installed by cloning the repository and running the following command:</p> <pre><code>python setup.py sdist\npip install dist/pypeakify-{VERSION}.tar.gz\n</code></pre> <p>where <code>{VERSION}</code> is the version number of the package.</p>"},{"location":"#usage","title":"Usage","text":"<p>See the usage guide for more information on how to use PyPeakify.</p>"},{"location":"#license","title":"License","text":"<p>PyPeakify is licensed under the GPL-3.0 license.</p>"},{"location":"#usage-in-literature","title":"Usage in Literature","text":"<p>PyPeakify (or its predecessor, ylftir), has been used in the following publications:</p> <ul> <li>Skin repair and infection control in diabetic, obese mice using bioactive laser-activated sealants</li> </ul>"},{"location":"baselines/","title":"Baseline Correction","text":""},{"location":"baselines/#baseline-usage","title":"Baseline Usage","text":"<p>Baseline correction is a pre-processing technique used to remove the background signal from a spectrum. PyPeakify provides a few options and a simple interface to apply baseline correction to a spectrum. The following baselines are available: - Identity baseline correction - Piecewise linear baseline correction - Cubic spline baseline correction</p> <p>Baselines are any callable object that takes a <code>numpy.ndarray</code> as input from the domain of the spectrum and returns a <code>numpy.ndarray</code> of the same shape. Any baseline correction can be pased to the <code>baseline</code> parameter of a <code>Deconvolution</code> object (see Deconvolution).</p> <pre><code>import numpy as np\n... # Other imports\nfrom pypeakify.baseline import PiecewiseLinearBaseline\n\n... # Load a spectrum, initialize peaks\n\nx_nodes = np.array([1600, 1700])\ny_nodes = np.array([1, 2])\n\nbaseline = PiecewiseLinearBaseline(x_nodes, y_nodes)\ndeconvolution = Deconvolution(peaks, baseline=baseline)\n</code></pre>"},{"location":"baselines/#pypeakify.baseline","title":"<code>pypeakify.baseline</code>","text":""},{"location":"baselines/#pypeakify.baseline.CubicSplineBaseline","title":"<code>CubicSplineBaseline</code>","text":"<p>Baseline represented by a cubic spline.</p> Source code in <code>src\\pypeakify\\baseline.py</code> <pre><code>class CubicSplineBaseline:\n    '''\n    Baseline represented by a cubic spline.\n    '''\n    def __init__(self, x, y, bc_type='not-a-knot'):\n        '''\n        Constructor for the cubic spline baseline.\n\n        Args:\n            x (numpy.ndarray): x-values of the cubic spline.\n            y (numpy.ndarray): y-values of the cubic spline.\n            bc_type (str): Type of boundary condition to use. Default is 'not-a-knot'. See `scipy.interpolate.CubicSpline` for more information.\n        '''\n        self.spline = CubicSpline(x, y)\n\n    def __call__(self, x):\n        '''\n        Calculates the value of the baseline at the given x-values.\n\n        Args:\n            x (numpy.ndarray): x-values at which to evaluate the baseline.\n        '''\n        return self.spline(x)\n</code></pre>"},{"location":"baselines/#pypeakify.baseline.CubicSplineBaseline.__call__","title":"<code>__call__(x)</code>","text":"<p>Calculates the value of the baseline at the given x-values.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>x-values at which to evaluate the baseline.</p> required Source code in <code>src\\pypeakify\\baseline.py</code> <pre><code>def __call__(self, x):\n    '''\n    Calculates the value of the baseline at the given x-values.\n\n    Args:\n        x (numpy.ndarray): x-values at which to evaluate the baseline.\n    '''\n    return self.spline(x)\n</code></pre>"},{"location":"baselines/#pypeakify.baseline.CubicSplineBaseline.__init__","title":"<code>__init__(x, y, bc_type='not-a-knot')</code>","text":"<p>Constructor for the cubic spline baseline.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>x-values of the cubic spline.</p> required <code>y</code> <code>ndarray</code> <p>y-values of the cubic spline.</p> required <code>bc_type</code> <code>str</code> <p>Type of boundary condition to use. Default is 'not-a-knot'. See <code>scipy.interpolate.CubicSpline</code> for more information.</p> <code>'not-a-knot'</code> Source code in <code>src\\pypeakify\\baseline.py</code> <pre><code>def __init__(self, x, y, bc_type='not-a-knot'):\n    '''\n    Constructor for the cubic spline baseline.\n\n    Args:\n        x (numpy.ndarray): x-values of the cubic spline.\n        y (numpy.ndarray): y-values of the cubic spline.\n        bc_type (str): Type of boundary condition to use. Default is 'not-a-knot'. See `scipy.interpolate.CubicSpline` for more information.\n    '''\n    self.spline = CubicSpline(x, y)\n</code></pre>"},{"location":"baselines/#pypeakify.baseline.IdentityBaseline","title":"<code>IdentityBaseline</code>","text":"<p>No baseline correction, or the identity baseline</p> Source code in <code>src\\pypeakify\\baseline.py</code> <pre><code>class IdentityBaseline:\n    '''\n    No baseline correction, or the identity baseline\n    '''\n    def __init__(self):\n        pass\n\n    def __call__(self, x):\n        '''\n        Calculates the value of the baseline at the given x-values.\n\n        Args:\n            x (numpy.ndarray): x-values at which to evaluate the baseline.\n        '''\n        return np.zeros_like(x)\n</code></pre>"},{"location":"baselines/#pypeakify.baseline.IdentityBaseline.__call__","title":"<code>__call__(x)</code>","text":"<p>Calculates the value of the baseline at the given x-values.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>x-values at which to evaluate the baseline.</p> required Source code in <code>src\\pypeakify\\baseline.py</code> <pre><code>def __call__(self, x):\n    '''\n    Calculates the value of the baseline at the given x-values.\n\n    Args:\n        x (numpy.ndarray): x-values at which to evaluate the baseline.\n    '''\n    return np.zeros_like(x)\n</code></pre>"},{"location":"baselines/#pypeakify.baseline.PiecewiseLinearBaseline","title":"<code>PiecewiseLinearBaseline</code>","text":"<p>Baseline represented by a piecewise linear function.</p> Source code in <code>src\\pypeakify\\baseline.py</code> <pre><code>class PiecewiseLinearBaseline:\n    '''\n    Baseline represented by a piecewise linear function.\n    '''\n    def __init__(self, x, y):\n        '''\n        Constructor for the piecewise linear baseline. \n\n        Any values outside of the range of the provided set of vertices are set to the value at the nearest edge vertex.\n\n        Args:\n            x (numpy.ndarray): x-values of the vertices of the piecewise linear function\n            y (numpy.ndarray): y-values of the vertices of the piecewise linear function\n        '''\n        self.x = x\n        self.y = y\n\n    def __call__(self, x):\n        '''\n        Calculates the value of the baseline at the given x-values.\n\n        Args:\n            x (numpy.ndarray): x-values at which to evaluate the baseline.\n        '''\n        return np.interp(x, self.x, self.y)\n</code></pre>"},{"location":"baselines/#pypeakify.baseline.PiecewiseLinearBaseline.__call__","title":"<code>__call__(x)</code>","text":"<p>Calculates the value of the baseline at the given x-values.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>x-values at which to evaluate the baseline.</p> required Source code in <code>src\\pypeakify\\baseline.py</code> <pre><code>def __call__(self, x):\n    '''\n    Calculates the value of the baseline at the given x-values.\n\n    Args:\n        x (numpy.ndarray): x-values at which to evaluate the baseline.\n    '''\n    return np.interp(x, self.x, self.y)\n</code></pre>"},{"location":"baselines/#pypeakify.baseline.PiecewiseLinearBaseline.__init__","title":"<code>__init__(x, y)</code>","text":"<p>Constructor for the piecewise linear baseline. </p> <p>Any values outside of the range of the provided set of vertices are set to the value at the nearest edge vertex.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>x-values of the vertices of the piecewise linear function</p> required <code>y</code> <code>ndarray</code> <p>y-values of the vertices of the piecewise linear function</p> required Source code in <code>src\\pypeakify\\baseline.py</code> <pre><code>def __init__(self, x, y):\n    '''\n    Constructor for the piecewise linear baseline. \n\n    Any values outside of the range of the provided set of vertices are set to the value at the nearest edge vertex.\n\n    Args:\n        x (numpy.ndarray): x-values of the vertices of the piecewise linear function\n        y (numpy.ndarray): y-values of the vertices of the piecewise linear function\n    '''\n    self.x = x\n    self.y = y\n</code></pre>"},{"location":"deconvolutions/","title":"Deconvolutions","text":""},{"location":"deconvolutions/#overview","title":"Overview","text":"<p>The <code>deconvolutions</code> module provides functions for deconvolving peaks from a spectrum. It establishes a least squares optimization problem to fit a sum of peaks to a spectrum, and provides a simple interface for solving this problem.</p>"},{"location":"deconvolutions/#deconvolution-usage","title":"Deconvolution Usage","text":"<p>Once baseline and peak objects have been initialized, a <code>Deconvolution</code> object can be created to fit the peaks to the spectrum.</p> <p>When fit, a deconvolution object modifies copies of the peak objects to fit the spectrum. The original peak objects are not modified, and can be used for other deconvolutions. If a deconvolution object is refit to a different spectrum, the current state of the peaks will be used as the initial guess in the optimization problem.</p> <p>As a useful utility, when the object is printed, the fitted peak parameters are displayed in table form using the <code>tabulate</code> package.</p> <pre><code>import numpy as np\n... # Other imports\nfrom pypeakify.deconvolution import Deconvolution\n\n... # Load a spectrum, initialize peaks and baseline\ndeconvolution = Deconvolution(peaks, baseline=baseline)\ndeconvolution.fit(spectrum)\n\nprint('Fitted peaks:')\nprint(deconvolution)\n</code></pre>"},{"location":"deconvolutions/#pypeakify.deconvolution","title":"<code>pypeakify.deconvolution</code>","text":""},{"location":"deconvolutions/#pypeakify.deconvolution.Deconvolution","title":"<code>Deconvolution</code>","text":"<p>A class representing a deconvolution of a spectrum.</p> Source code in <code>src\\pypeakify\\deconvolution.py</code> <pre><code>class Deconvolution:\n    '''\n    A class representing a deconvolution of a spectrum.\n    '''\n\n    def __init__(self, peaks, baseline=IdentityBaseline()):\n        '''\n        Constructor for the Deconvolution class.\n\n        Args:\n            peaks (list): List of Peak objects to be fit to the spectrum.\n            baseline (Baseline): Baseline for fitting peaks. Default is the identity baseline.\n        '''\n        self.peaks = [copy.deepcopy(peak) for peak in peaks]\n        self.baseline = baseline\n\n        self.N = len(peaks)\n\n    def fit(self, x, y):\n        '''\n        Fits the peaks to the spectrum.\n\n        Args:\n            x (numpy.ndarray): x-values at which to evaluate the spectrum.\n            y (numpy.ndarray): y-values of the spectrum.\n        '''\n        base = self.baseline(x)\n\n        # rescale so numerically feasible\n        scale_x = np.max(x) - np.min(x)\n\n        fit_params = np.zeros(3*self.N)\n        min_bounds = np.zeros_like(fit_params)\n        max_bounds = np.zeros_like(fit_params)\n\n        for i, peak in enumerate(self.peaks):\n            fit_params[3*i:3*i+3] = [peak.width / scale_x, peak.amplitude, peak.position / scale_x]\n\n            min_bounds[3*i:3*i+3] = [peak.constrain_width[0] / scale_x, peak.constrain_amplitude[0], peak.constrain_position[0] / scale_x]\n            max_bounds[3*i:3*i+3] = [peak.constrain_width[1] / scale_x, peak.constrain_amplitude[1], peak.constrain_position[1] / scale_x]\n\n        def optim_func(x0, *params):\n            '''\n            Function to be minimized in the optimization process.\n\n            Args:\n                x (numpy.ndarray): x-values at which to evaluate the function.\n                *params: Parameters to be optimized.\n            '''\n            y0 = np.zeros_like(x)\n            for i in range(0, len(params), 3):\n                peak = Peak(self.peaks[int(i // 3)].peak_type, *params[i:i+3])\n                y0 += peak(x0)\n            return y0\n\n        self.fit_params, self.pcov = curve_fit(optim_func, x / scale_x, y - base, p0=fit_params, bounds=(min_bounds, max_bounds), maxfev=100000)\n        self.perr = np.sqrt(np.diag(self.pcov))\n\n        for i in range(self.N):\n            self.peaks[i].width, self.peaks[i].amplitude, self.peaks[i].position = self.fit_params[3*i:3*i+3]\n\n            fp = self.fit_params[3*i:3*i+3]\n\n            self.peaks[i].width *= scale_x\n            self.peaks[i].position *= scale_x\n\n            perr = self.perr[3*i:3*i+3]\n\n            self.peaks[i].set_perr(perr[0] * scale_x, perr[1], perr[2] * scale_x)\n\n        print(self)\n\n    def __str__(self):\n        '''\n        Returns a string representation of the deconvolution.\n        '''\n        return tabulate(\n            [[peak.peak_type, peak.width, peak.amplitude, peak.position] for peak in self.peaks],\n            headers=['Peak Type', 'Width', 'Amplitude', 'Position']\n        )\n\n    def __call__(self, x):\n        '''\n        Calculates the value of the deconvolution at the given x-values.\n\n        Args:\n            x (numpy.ndarray): x-values at which to evaluate the deconvolution.\n        '''\n        y = np.zeros_like(x)\n        for i in range(0, self.N*3, 3):\n            y += self.peaks[int(i // 3)](x)\n        return y\n\n    def plot(self, ax, x, y=None, show_base=True, show_peaks=True, show_error=False, **kwargs):\n        '''\n        Plots the deconvolution on the given axis.\n\n        Args:\n            ax (matplotlib.axes.Axes): Axis on which to plot the deconvolution.\n            x (numpy.ndarray): x-values at which to evaluate the deconvolution.\n            y (numpy.ndarray): y-values of the ground truth spectrum. Optional.\n            show_base (bool): Whether or not to plot the baseline.\n            show_peaks (bool): Whether or not to plot the individual peaks.\n            show_error (bool): Whether or not to plot the error bars.\n            **kwargs: Additional matplotlib keyword arguments to be passed to the plot.\n        '''\n        if show_peaks:\n            for peak in self.peaks:\n                peak.plot(ax, x, baseline=self.baseline if show_base else None, show_error=show_error, color='r', ls='--', **kwargs)\n\n        y_pred = self(x)\n        if show_base:\n            y_pred += self.baseline(x)\n        ax.plot(x, y_pred, c='b', ls='--', label='Deconvolution', **kwargs)\n\n        if y is not None:\n            ax.plot(x, y, label='Ground Truth', c='k')\n</code></pre>"},{"location":"deconvolutions/#pypeakify.deconvolution.Deconvolution.__call__","title":"<code>__call__(x)</code>","text":"<p>Calculates the value of the deconvolution at the given x-values.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>x-values at which to evaluate the deconvolution.</p> required Source code in <code>src\\pypeakify\\deconvolution.py</code> <pre><code>def __call__(self, x):\n    '''\n    Calculates the value of the deconvolution at the given x-values.\n\n    Args:\n        x (numpy.ndarray): x-values at which to evaluate the deconvolution.\n    '''\n    y = np.zeros_like(x)\n    for i in range(0, self.N*3, 3):\n        y += self.peaks[int(i // 3)](x)\n    return y\n</code></pre>"},{"location":"deconvolutions/#pypeakify.deconvolution.Deconvolution.__init__","title":"<code>__init__(peaks, baseline=IdentityBaseline())</code>","text":"<p>Constructor for the Deconvolution class.</p> <p>Parameters:</p> Name Type Description Default <code>peaks</code> <code>list</code> <p>List of Peak objects to be fit to the spectrum.</p> required <code>baseline</code> <code>Baseline</code> <p>Baseline for fitting peaks. Default is the identity baseline.</p> <code>IdentityBaseline()</code> Source code in <code>src\\pypeakify\\deconvolution.py</code> <pre><code>def __init__(self, peaks, baseline=IdentityBaseline()):\n    '''\n    Constructor for the Deconvolution class.\n\n    Args:\n        peaks (list): List of Peak objects to be fit to the spectrum.\n        baseline (Baseline): Baseline for fitting peaks. Default is the identity baseline.\n    '''\n    self.peaks = [copy.deepcopy(peak) for peak in peaks]\n    self.baseline = baseline\n\n    self.N = len(peaks)\n</code></pre>"},{"location":"deconvolutions/#pypeakify.deconvolution.Deconvolution.__str__","title":"<code>__str__()</code>","text":"<p>Returns a string representation of the deconvolution.</p> Source code in <code>src\\pypeakify\\deconvolution.py</code> <pre><code>def __str__(self):\n    '''\n    Returns a string representation of the deconvolution.\n    '''\n    return tabulate(\n        [[peak.peak_type, peak.width, peak.amplitude, peak.position] for peak in self.peaks],\n        headers=['Peak Type', 'Width', 'Amplitude', 'Position']\n    )\n</code></pre>"},{"location":"deconvolutions/#pypeakify.deconvolution.Deconvolution.fit","title":"<code>fit(x, y)</code>","text":"<p>Fits the peaks to the spectrum.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>x-values at which to evaluate the spectrum.</p> required <code>y</code> <code>ndarray</code> <p>y-values of the spectrum.</p> required Source code in <code>src\\pypeakify\\deconvolution.py</code> <pre><code>def fit(self, x, y):\n    '''\n    Fits the peaks to the spectrum.\n\n    Args:\n        x (numpy.ndarray): x-values at which to evaluate the spectrum.\n        y (numpy.ndarray): y-values of the spectrum.\n    '''\n    base = self.baseline(x)\n\n    # rescale so numerically feasible\n    scale_x = np.max(x) - np.min(x)\n\n    fit_params = np.zeros(3*self.N)\n    min_bounds = np.zeros_like(fit_params)\n    max_bounds = np.zeros_like(fit_params)\n\n    for i, peak in enumerate(self.peaks):\n        fit_params[3*i:3*i+3] = [peak.width / scale_x, peak.amplitude, peak.position / scale_x]\n\n        min_bounds[3*i:3*i+3] = [peak.constrain_width[0] / scale_x, peak.constrain_amplitude[0], peak.constrain_position[0] / scale_x]\n        max_bounds[3*i:3*i+3] = [peak.constrain_width[1] / scale_x, peak.constrain_amplitude[1], peak.constrain_position[1] / scale_x]\n\n    def optim_func(x0, *params):\n        '''\n        Function to be minimized in the optimization process.\n\n        Args:\n            x (numpy.ndarray): x-values at which to evaluate the function.\n            *params: Parameters to be optimized.\n        '''\n        y0 = np.zeros_like(x)\n        for i in range(0, len(params), 3):\n            peak = Peak(self.peaks[int(i // 3)].peak_type, *params[i:i+3])\n            y0 += peak(x0)\n        return y0\n\n    self.fit_params, self.pcov = curve_fit(optim_func, x / scale_x, y - base, p0=fit_params, bounds=(min_bounds, max_bounds), maxfev=100000)\n    self.perr = np.sqrt(np.diag(self.pcov))\n\n    for i in range(self.N):\n        self.peaks[i].width, self.peaks[i].amplitude, self.peaks[i].position = self.fit_params[3*i:3*i+3]\n\n        fp = self.fit_params[3*i:3*i+3]\n\n        self.peaks[i].width *= scale_x\n        self.peaks[i].position *= scale_x\n\n        perr = self.perr[3*i:3*i+3]\n\n        self.peaks[i].set_perr(perr[0] * scale_x, perr[1], perr[2] * scale_x)\n\n    print(self)\n</code></pre>"},{"location":"deconvolutions/#pypeakify.deconvolution.Deconvolution.plot","title":"<code>plot(ax, x, y=None, show_base=True, show_peaks=True, show_error=False, **kwargs)</code>","text":"<p>Plots the deconvolution on the given axis.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>Axis on which to plot the deconvolution.</p> required <code>x</code> <code>ndarray</code> <p>x-values at which to evaluate the deconvolution.</p> required <code>y</code> <code>ndarray</code> <p>y-values of the ground truth spectrum. Optional.</p> <code>None</code> <code>show_base</code> <code>bool</code> <p>Whether or not to plot the baseline.</p> <code>True</code> <code>show_peaks</code> <code>bool</code> <p>Whether or not to plot the individual peaks.</p> <code>True</code> <code>show_error</code> <code>bool</code> <p>Whether or not to plot the error bars.</p> <code>False</code> <code>**kwargs</code> <p>Additional matplotlib keyword arguments to be passed to the plot.</p> <code>{}</code> Source code in <code>src\\pypeakify\\deconvolution.py</code> <pre><code>def plot(self, ax, x, y=None, show_base=True, show_peaks=True, show_error=False, **kwargs):\n    '''\n    Plots the deconvolution on the given axis.\n\n    Args:\n        ax (matplotlib.axes.Axes): Axis on which to plot the deconvolution.\n        x (numpy.ndarray): x-values at which to evaluate the deconvolution.\n        y (numpy.ndarray): y-values of the ground truth spectrum. Optional.\n        show_base (bool): Whether or not to plot the baseline.\n        show_peaks (bool): Whether or not to plot the individual peaks.\n        show_error (bool): Whether or not to plot the error bars.\n        **kwargs: Additional matplotlib keyword arguments to be passed to the plot.\n    '''\n    if show_peaks:\n        for peak in self.peaks:\n            peak.plot(ax, x, baseline=self.baseline if show_base else None, show_error=show_error, color='r', ls='--', **kwargs)\n\n    y_pred = self(x)\n    if show_base:\n        y_pred += self.baseline(x)\n    ax.plot(x, y_pred, c='b', ls='--', label='Deconvolution', **kwargs)\n\n    if y is not None:\n        ax.plot(x, y, label='Ground Truth', c='k')\n</code></pre>"},{"location":"peaks/","title":"Peaks","text":""},{"location":"peaks/#overview","title":"Overview","text":"<p>PyPeakify currently supports two primary peak types, Gaussians and Lorentzians. The peak type can be chosen in the constructor, or changed at any time by changing the <code>peak_type</code>.</p> <p>Additionally, you can provide optimization constraints directly to the peak objects themselves by modifying the <code>constrain_X</code> attributes, where <code>X</code> is in the set {<code>width</code>, <code>amplitude</code>, <code>position</code>}. These constraints are respected by the optimization algorithm when fitting the peaks to a spectrum, and are not asserted if parameters are modified outside of that context.</p> <pre><code>from pypeakify.peak import Peak\n\n# Create a Gaussian peak\ngaussian_peak = Peak(peak_type='gaussian', width=1.0, amplitude=1.0, position=0.0)\n\n# Create a Lorentzian peak\nlorentzian_peak = Peak(peak_type='lorentzian', width=1.0, amplitude=1.0, position=0.0)\n</code></pre>"},{"location":"peaks/#pypeakify.peak","title":"<code>pypeakify.peak</code>","text":""},{"location":"peaks/#pypeakify.peak.Peak","title":"<code>Peak</code>","text":"<p>A class representing a peak in a spectrum.</p> <p>Notably, the user initializes a peak, and then uses a <code>Deconvolution</code> object to fit the peak to a spectrum. The peak can be plotted using the <code>plot</code> method.</p> Source code in <code>src\\pypeakify\\peak.py</code> <pre><code>class Peak:\n    '''\n    A class representing a peak in a spectrum.\n\n    Notably, the user initializes a peak, and then uses a `Deconvolution` object to fit the peak to a spectrum.\n    The peak can be plotted using the `plot` method.\n    '''\n\n    def __init__(self, peak_type, width, amplitude, position, constrain_width=(0,np.inf), constrain_amplitude=(0,np.inf), constrain_position=(-np.inf,np.inf)):\n        '''\n        Constructor for the Peak class.\n\n        Args:\n            peak_type (str): Type of peak to be used. Of 'gaussian' or 'lorentzian'.\n            width (float): Initial width of the peak.\n            amplitude (float): Initial amplitude of the peak.\n            position (float): Initial position of the peak.\n            constrain_width (tuple): Tuple of the form (min, max); range for the width of the peak.\n            constrain_amplitude (tuple): Tuple of the form (min, max); range for the amplitude of the peak.\n            constrain_position (tuple): Tuple of the form (min, max); range for the position of the peak.\n        '''\n\n        assert peak_type in ['gaussian', 'lorentzian'], \"peak_type must be 'gaussian' or 'lorentzian'.\"\n\n        self.peak_type = peak_type\n        self.width = width\n        self.amplitude = amplitude\n        self.position = position\n        self.constrain_width = constrain_width\n        self.constrain_amplitude = constrain_amplitude\n        self.constrain_position = constrain_position\n\n    def __call__(self, x):\n        '''\n        Calculates the value of the peak at the given x-values.\n\n        Args:\n            x (numpy.ndarray): x-values at which to evaluate the peak.\n        '''\n        if self.peak_type == 'gaussian':\n            return gaussian(x, self.width, self.amplitude, self.position)\n        elif self.peak_type == 'lorentzian':\n            return lorentzian(x, self.width, self.amplitude, self.position)\n        else:\n            raise ValueError(\"`peak_type` must be 'gaussian' or 'lorentzian'.\")\n\n    def set_perr(self, width_perr, amplitude_perr, position_perr):\n        self.width_perr = width_perr\n        self.amplitude_perr = amplitude_perr\n        self.position_perr = position_perr\n\n    def get_fit_error(self, x):\n        '''\n        Calculates the error bars of the peak at the given x-values given 1-sigma from the fit, as set by `set_perr`.\n\n        Returns a pair of the upper (`ub`) and lower (`lb`) bounds of the peak where `ub` and `lb` are the same shape as `x`.\n\n        Args:\n            x (numpy.ndarray): x-values at which to evaluate the peak.\n        '''\n        if self.peak_type == 'gaussian':\n            ub = gaussian(x, self.width + self.width_perr, self.amplitude + self.amplitude_perr, self.position + self.position_perr)\n            lb = gaussian(x, self.width - self.width_perr, self.amplitude - self.amplitude_perr, self.position - self.position_perr)\n            return ub, lb\n        elif self.peak_type == 'lorentzian':\n            ub = lorentzian(x, self.width + self.width_perr, self.amplitude + self.amplitude_perr, self.position + self.position_perr)\n            lb = lorentzian(x, self.width - self.width_perr, self.amplitude - self.amplitude_perr, self.position - self.position_perr)\n            return ub, lb\n        else:\n            raise ValueError(\"`peak_type` must be 'gaussian' or 'lorentzian'.\")\n\n    def plot(self, ax, x=None, baseline=None, show_error=False, **kwargs):\n        '''\n        Plots the peak on the given axis.\n\n        Args:\n            ax (matplotlib.axes.Axes): Axis on which to plot the peak.\n            x (numpy.ndarray): x-values at which to evaluate the peak. If None, x-values are generated near the position.\n            baseline (Baseline): Baseline object to be plotted along with the peak. If None, no baseline is plotted.\n            show_error (bool): Whether or not to plot error bars on the peak.\n            **kwargs: Additional matplotlib keyword arguments to be passed to the plot function.\n        '''\n        if x is None:\n            fwhm = self.get_fwhm()\n            x = np.linspace(self.position - 4*fwhm, self.position + 4*fwhm, 1000)\n\n        if show_error:\n            ub, lb = self.get_fit_error(x)\n            if baseline is not None:\n                ub += baseline(x)\n                lb += baseline(x)\n            ax.fill_between(x, lb, ub, alpha=0.5, **kwargs)\n\n        y = self(x)\n        if baseline is not None:\n            y += baseline(x)\n        ax.plot(x, y, **kwargs)\n\n    def get_fwhm(self):\n        '''\n        Gets the full width at half maximum of the peak.\n        '''\n        if self.peak_type == 'gaussian':\n            # 2 sqrt(2 ln(2)) ~= 2.35482005\n            return 2.35482005 * self.width\n        elif self.peak_type == 'lorentzian':\n            return 2 * self.width\n        else:\n            raise ValueError(\"peak_type must be 'gaussian' or 'lorentzian'.\")\n</code></pre>"},{"location":"peaks/#pypeakify.peak.Peak.__call__","title":"<code>__call__(x)</code>","text":"<p>Calculates the value of the peak at the given x-values.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>x-values at which to evaluate the peak.</p> required Source code in <code>src\\pypeakify\\peak.py</code> <pre><code>def __call__(self, x):\n    '''\n    Calculates the value of the peak at the given x-values.\n\n    Args:\n        x (numpy.ndarray): x-values at which to evaluate the peak.\n    '''\n    if self.peak_type == 'gaussian':\n        return gaussian(x, self.width, self.amplitude, self.position)\n    elif self.peak_type == 'lorentzian':\n        return lorentzian(x, self.width, self.amplitude, self.position)\n    else:\n        raise ValueError(\"`peak_type` must be 'gaussian' or 'lorentzian'.\")\n</code></pre>"},{"location":"peaks/#pypeakify.peak.Peak.__init__","title":"<code>__init__(peak_type, width, amplitude, position, constrain_width=(0, np.inf), constrain_amplitude=(0, np.inf), constrain_position=(-np.inf, np.inf))</code>","text":"<p>Constructor for the Peak class.</p> <p>Parameters:</p> Name Type Description Default <code>peak_type</code> <code>str</code> <p>Type of peak to be used. Of 'gaussian' or 'lorentzian'.</p> required <code>width</code> <code>float</code> <p>Initial width of the peak.</p> required <code>amplitude</code> <code>float</code> <p>Initial amplitude of the peak.</p> required <code>position</code> <code>float</code> <p>Initial position of the peak.</p> required <code>constrain_width</code> <code>tuple</code> <p>Tuple of the form (min, max); range for the width of the peak.</p> <code>(0, inf)</code> <code>constrain_amplitude</code> <code>tuple</code> <p>Tuple of the form (min, max); range for the amplitude of the peak.</p> <code>(0, inf)</code> <code>constrain_position</code> <code>tuple</code> <p>Tuple of the form (min, max); range for the position of the peak.</p> <code>(-inf, inf)</code> Source code in <code>src\\pypeakify\\peak.py</code> <pre><code>def __init__(self, peak_type, width, amplitude, position, constrain_width=(0,np.inf), constrain_amplitude=(0,np.inf), constrain_position=(-np.inf,np.inf)):\n    '''\n    Constructor for the Peak class.\n\n    Args:\n        peak_type (str): Type of peak to be used. Of 'gaussian' or 'lorentzian'.\n        width (float): Initial width of the peak.\n        amplitude (float): Initial amplitude of the peak.\n        position (float): Initial position of the peak.\n        constrain_width (tuple): Tuple of the form (min, max); range for the width of the peak.\n        constrain_amplitude (tuple): Tuple of the form (min, max); range for the amplitude of the peak.\n        constrain_position (tuple): Tuple of the form (min, max); range for the position of the peak.\n    '''\n\n    assert peak_type in ['gaussian', 'lorentzian'], \"peak_type must be 'gaussian' or 'lorentzian'.\"\n\n    self.peak_type = peak_type\n    self.width = width\n    self.amplitude = amplitude\n    self.position = position\n    self.constrain_width = constrain_width\n    self.constrain_amplitude = constrain_amplitude\n    self.constrain_position = constrain_position\n</code></pre>"},{"location":"peaks/#pypeakify.peak.Peak.get_fit_error","title":"<code>get_fit_error(x)</code>","text":"<p>Calculates the error bars of the peak at the given x-values given 1-sigma from the fit, as set by <code>set_perr</code>.</p> <p>Returns a pair of the upper (<code>ub</code>) and lower (<code>lb</code>) bounds of the peak where <code>ub</code> and <code>lb</code> are the same shape as <code>x</code>.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>x-values at which to evaluate the peak.</p> required Source code in <code>src\\pypeakify\\peak.py</code> <pre><code>def get_fit_error(self, x):\n    '''\n    Calculates the error bars of the peak at the given x-values given 1-sigma from the fit, as set by `set_perr`.\n\n    Returns a pair of the upper (`ub`) and lower (`lb`) bounds of the peak where `ub` and `lb` are the same shape as `x`.\n\n    Args:\n        x (numpy.ndarray): x-values at which to evaluate the peak.\n    '''\n    if self.peak_type == 'gaussian':\n        ub = gaussian(x, self.width + self.width_perr, self.amplitude + self.amplitude_perr, self.position + self.position_perr)\n        lb = gaussian(x, self.width - self.width_perr, self.amplitude - self.amplitude_perr, self.position - self.position_perr)\n        return ub, lb\n    elif self.peak_type == 'lorentzian':\n        ub = lorentzian(x, self.width + self.width_perr, self.amplitude + self.amplitude_perr, self.position + self.position_perr)\n        lb = lorentzian(x, self.width - self.width_perr, self.amplitude - self.amplitude_perr, self.position - self.position_perr)\n        return ub, lb\n    else:\n        raise ValueError(\"`peak_type` must be 'gaussian' or 'lorentzian'.\")\n</code></pre>"},{"location":"peaks/#pypeakify.peak.Peak.get_fwhm","title":"<code>get_fwhm()</code>","text":"<p>Gets the full width at half maximum of the peak.</p> Source code in <code>src\\pypeakify\\peak.py</code> <pre><code>def get_fwhm(self):\n    '''\n    Gets the full width at half maximum of the peak.\n    '''\n    if self.peak_type == 'gaussian':\n        # 2 sqrt(2 ln(2)) ~= 2.35482005\n        return 2.35482005 * self.width\n    elif self.peak_type == 'lorentzian':\n        return 2 * self.width\n    else:\n        raise ValueError(\"peak_type must be 'gaussian' or 'lorentzian'.\")\n</code></pre>"},{"location":"peaks/#pypeakify.peak.Peak.plot","title":"<code>plot(ax, x=None, baseline=None, show_error=False, **kwargs)</code>","text":"<p>Plots the peak on the given axis.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>Axis on which to plot the peak.</p> required <code>x</code> <code>ndarray</code> <p>x-values at which to evaluate the peak. If None, x-values are generated near the position.</p> <code>None</code> <code>baseline</code> <code>Baseline</code> <p>Baseline object to be plotted along with the peak. If None, no baseline is plotted.</p> <code>None</code> <code>show_error</code> <code>bool</code> <p>Whether or not to plot error bars on the peak.</p> <code>False</code> <code>**kwargs</code> <p>Additional matplotlib keyword arguments to be passed to the plot function.</p> <code>{}</code> Source code in <code>src\\pypeakify\\peak.py</code> <pre><code>def plot(self, ax, x=None, baseline=None, show_error=False, **kwargs):\n    '''\n    Plots the peak on the given axis.\n\n    Args:\n        ax (matplotlib.axes.Axes): Axis on which to plot the peak.\n        x (numpy.ndarray): x-values at which to evaluate the peak. If None, x-values are generated near the position.\n        baseline (Baseline): Baseline object to be plotted along with the peak. If None, no baseline is plotted.\n        show_error (bool): Whether or not to plot error bars on the peak.\n        **kwargs: Additional matplotlib keyword arguments to be passed to the plot function.\n    '''\n    if x is None:\n        fwhm = self.get_fwhm()\n        x = np.linspace(self.position - 4*fwhm, self.position + 4*fwhm, 1000)\n\n    if show_error:\n        ub, lb = self.get_fit_error(x)\n        if baseline is not None:\n            ub += baseline(x)\n            lb += baseline(x)\n        ax.fill_between(x, lb, ub, alpha=0.5, **kwargs)\n\n    y = self(x)\n    if baseline is not None:\n        y += baseline(x)\n    ax.plot(x, y, **kwargs)\n</code></pre>"},{"location":"peaks/#pypeakify.peak.gaussian","title":"<code>gaussian(x, width, amplitude, position)</code>","text":"<p>Calculates the value of a Gaussian peak at the given x-values.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>x-values at which to evaluate the peak.</p> required <code>width</code> <code>float</code> <p>Width of the peak.</p> required <code>amplitude</code> <code>float</code> <p>Amplitude of the peak.</p> required <code>position</code> <code>float</code> <p>Position of the peak.</p> required Source code in <code>src\\pypeakify\\peak.py</code> <pre><code>def gaussian(x, width, amplitude, position):\n    '''\n    Calculates the value of a Gaussian peak at the given x-values.\n\n    Args:\n        x (numpy.ndarray): x-values at which to evaluate the peak.\n        width (float): Width of the peak.\n        amplitude (float): Amplitude of the peak.\n        position (float): Position of the peak.\n    '''\n    return amplitude * np.exp(-0.5 * ((x - position) / width)**2)\n</code></pre>"},{"location":"peaks/#pypeakify.peak.lorentzian","title":"<code>lorentzian(x, width, amplitude, position)</code>","text":"<p>Calculates the value of a Lorentzian peak at the given x-values.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>x-values at which to evaluate the peak.</p> required <code>width</code> <code>float</code> <p>Width of the peak.</p> required <code>amplitude</code> <code>float</code> <p>Amplitude of the peak.</p> required <code>position</code> <code>float</code> <p>Position of the peak.</p> required Source code in <code>src\\pypeakify\\peak.py</code> <pre><code>def lorentzian(x, width, amplitude, position):\n    '''\n    Calculates the value of a Lorentzian peak at the given x-values.\n\n    Args:\n        x (numpy.ndarray): x-values at which to evaluate the peak.\n        width (float): Width of the peak.\n        amplitude (float): Amplitude of the peak.\n        position (float): Position of the peak.\n    '''\n    return amplitude / (1 + ((x - position) / width)**2)\n</code></pre>"},{"location":"plotting/","title":"Plotting","text":"<p>Plotting that is supported by PyPeakify is all handled using <code>matplotlib</code>, and as such, all <code>Peak</code> objects and <code>Deconvolution</code> objects have plotting functions that accept a <code>matplotlib</code> axis object as input. </p>"},{"location":"plotting/#error-bars","title":"Error Bars","text":"<p>The <code>show_error</code> parameter of the <code>plot</code> function can be used to show error bars for the peaks, computed as the 1-sigma error bars from the covariance matrix of the optimization.</p> <p>Below, a linear baseline correction with three Gaussian peaks is plotted with 1-sigma error bars.</p> <pre><code>... # Load spectrum, initialize peaks and baseline\n\n# Fit the peaks to the spectrum\ndeconv = Deconvolution([p1, p2, p3], baseline)\ndeconv.fit(x, y)\n\n# Plot the spectrum and the fitted peaks with error bars\nplt.figure()\n\nplt.plot(x, y, c='k')\nplt.plot(x, baseline(x), c='c', ls='-')\n\ndeconv.plot(plt.gca(), x, y, show_error=True)\n\nplt.legend()\nplt.show()\n</code></pre> <p></p>"},{"location":"plotting/#customization","title":"Customization","text":"<p>All <code>plot</code> functions support <code>**kwargs</code> -- keyword arguments -- that are passed directly to the <code>matplotlib</code> plotting functions. This allows for customization of the plot, such as changing the color of the peaks, the linestyle, or the linewidth.</p> <p>Outside of the parameters offered by the <code>plot</code> functions of each object, it is easy to generate the data used in the plotting by using functions provided by each object.</p> <p>Each <code>Peak</code> object in the <code>peaks</code> member of a <code>Deconvolution</code> object is a callable object that can be used to generate the peak data over a set of <code>x</code> values, i.e. <pre><code>peak_1 = deconv.peaks[0]\nx = np.linspace(0, 10, 1000)\ny = peak_1(x)\n</code></pre> The upper and lower error bars can be generated similarly, using the <code>get_fit_error</code> function of the <code>Peak</code> object, but only after the <code>Peak</code> object has been fit to a spectrum. <pre><code>peak_1 = deconv.peaks[0]\nx = np.linspace(0, 10, 1000)\nub, lb = peak_1.get_fit_error(x)\n</code></pre></p> <p>Similarly, both the <code>Baseline</code> and <code>Deconvolution</code> objects are themselves callable, and the same call signature can be used to generate the baseline correction along a set of <code>x</code> values as well as to generate the fit itself. <pre><code>x = np.linspace(0, 10, 1000)\n\nfull_fit = deconv(x)\nbaseline = deconv.baseline(x)\n</code></pre></p> <p>This generated data can then be used to plot the data in any way that is desired, using the full power of <code>matplotlib</code>, or other plotting libraries.</p>"},{"location":"reading_files/","title":"File Loading and Utility Functions","text":""},{"location":"reading_files/#overview","title":"Overview","text":"<p>The <code>filereader</code> module provides some utility functions for loading files and pre-processing spectra. In principle, any spectra in the form of 1D numpy arrays of x (abscissa) and y (ordinate) data can be used for PyPeakify. </p>"},{"location":"reading_files/#pypeakify.filereader","title":"<code>pypeakify.filereader</code>","text":""},{"location":"reading_files/#pypeakify.filereader.crop","title":"<code>crop(x, y, range)</code>","text":"<p>Crop x, y data to specified x range. <code>range</code> must be a pair of values in the domain of x.</p> <p>x and y must have the same shape.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>array</code> <p>x data.</p> required <code>y</code> <code>array</code> <p>y data.</p> required <code>range</code> <code>tuple</code> <p>x range to crop x, y data to, in the form (x_min, x_max).</p> required Source code in <code>src\\pypeakify\\filereader.py</code> <pre><code>def crop(x, y, range):\n    '''\n    Crop x, y data to specified x range. `range` must be a pair of values in the domain of x.\n\n    x and y must have the same shape.\n\n    Args:\n        x (np.array): x data.\n        y (np.array): y data.\n        range (tuple): x range to crop x, y data to, in the form (x_min, x_max).\n    '''\n    diffs1 = np.abs(x - range[0])\n    diffs2 = np.abs(x - range[1])\n    i1 = np.argmin(diffs1)\n    i2 = np.argmin(diffs2)\n    x = x[i1:i2]\n    y = y[i1:i2]\n    return x, y\n</code></pre>"},{"location":"reading_files/#pypeakify.filereader.import_ascii_file","title":"<code>import_ascii_file(fname, delim=None)</code>","text":"<p>Import x (abscissa), y (ordinate) spectrum data from file. Assumes two column ascii format where the first column is x and the second column is y.</p> <p>Parameters:</p> Name Type Description Default <code>fname</code> <code>str</code> <p>Path to file.</p> required <code>delim</code> <code>str</code> <p>Delimiter used in file. If None, will attempt to guess.</p> <code>None</code> Source code in <code>src\\pypeakify\\filereader.py</code> <pre><code>def import_ascii_file(fname, delim=None):\n    '''\n    Import x (abscissa), y (ordinate) spectrum data from file. Assumes two column ascii format where the first column is x and the second column is y.\n\n    Args:\n        fname (str): Path to file.\n        delim (str): Delimiter used in file. If None, will attempt to guess.\n    '''\n    try:\n        f = open(fname, 'r')\n    except IOError:\n        print(f'Unable to open file at {fname}')\n        return None, None\n    except Exception as e:\n        print(f'Error: {e}')\n        return None, None\n    else:\n        with f:\n            fc = f.read()\n            if delim is None:\n                sniffer = csv.Sniffer()\n                delimiter = sniffer.sniff(fc).delimiter\n                x, y = np.transpose(np.genfromtxt(fc.splitlines(), delimiter=delimiter))\n            else:\n                x, y = np.transpose(np.genfromtxt(fc.splitlines(), delimiter=delim))\n\n            if x is None or y is None:\n                print(f'Error: Unable to parse data from {fname}')\n                return None, None\n\n            # sort y w.r.t. x\n            x_ind = np.argsort(x)\n            x, y = x[x_ind], y[x_ind]\n            return x, y\n</code></pre>"},{"location":"reading_files/#pypeakify.filereader.import_ascii_url","title":"<code>import_ascii_url(url, delim=None)</code>","text":"<p>Import x (abscissa), y (ordinate) spectrum data from URL. Assumes two column ascii format where the first column is x and the second column is y.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to file.</p> required <code>delim</code> <code>str</code> <p>Delimiter used in file. If None, will attempt to guess.</p> <code>None</code> Source code in <code>src\\pypeakify\\filereader.py</code> <pre><code>def import_ascii_url(url, delim=None):\n    '''\n    Import x (abscissa), y (ordinate) spectrum data from URL. Assumes two column ascii format where the first column is x and the second column is y.\n\n    Args:\n        url (str): URL to file.\n        delim (str): Delimiter used in file. If None, will attempt to guess.\n    '''\n    try:\n        response = requests.get(url)\n        if delim is None:\n            sniffer = csv.Sniffer()\n            delimiter = sniffer.sniff(response.text).delimiter\n            x, y = np.transpose(np.genfromtxt(response.text.splitlines(), delimiter=delimiter))\n        else:\n            x, y = np.transpose(np.genfromtxt(response.text.splitlines(), delimiter=delim))\n\n        if x is None or y is None:\n            print(f'Error: Unable to parse data from {url}')\n            return None, None\n\n        # sort y w.r.t. x\n        x_ind = np.argsort(x)\n        x, y = x[x_ind], y[x_ind]\n        return x, y\n    except IOError:\n        print(f'Unable to open file at {url}')\n        return None, None\n    except Exception as e:\n        print(f'Error: {e}')\n        return None, None\n</code></pre>"},{"location":"reading_files/#pypeakify.filereader.import_jcamp_file","title":"<code>import_jcamp_file(fname)</code>","text":"<p>Import spectrum data from JCAMP file.</p> <p>Note</p> <p>JCAMP-DX files are loaded using the <code>jcamp</code> package. Unlike ASCII files which are assumed to have a single spectrum, JCAMP files can contain multiple spectra, and should be handled accordingly by the user.</p> <p>Parameters:</p> Name Type Description Default <code>fname</code> <code>str</code> <p>Path to file.</p> required Source code in <code>src\\pypeakify\\filereader.py</code> <pre><code>def import_jcamp_file(fname):\n    '''\n    Import spectrum data from JCAMP file.\n\n    !!! note\n        JCAMP-DX files are loaded using the [`jcamp`](https://pypi.org/project/jcamp/) package.\n        Unlike ASCII files which are assumed to have a single spectrum, JCAMP files can contain multiple spectra, and should be handled accordingly by the user.\n\n    Args:\n        fname (str): Path to file.\n    '''\n    return jcamp.jcamp_readfile(fname)\n</code></pre>"},{"location":"reading_files/#pypeakify.filereader.import_jcamp_url","title":"<code>import_jcamp_url(url)</code>","text":"<p>Import spectrum data from JCAMP file at URL.</p> <p>Note</p> <p>JCAMP-DX files are loaded using the <code>jcamp</code> package. Unlike ASCII files which are assumed to have a single spectrum, JCAMP files can contain multiple spectra, and should be handled accordingly by the user.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to file.</p> required Source code in <code>src\\pypeakify\\filereader.py</code> <pre><code>def import_jcamp_url(url):\n    '''\n    Import spectrum data from JCAMP file at URL.\n\n    !!! note\n        JCAMP-DX files are loaded using the [`jcamp`](https://pypi.org/project/jcamp/) package.\n        Unlike ASCII files which are assumed to have a single spectrum, JCAMP files can contain multiple spectra, and should be handled accordingly by the user.\n\n    Args:\n        url (str): URL to file.\n    '''\n    try:\n        response = requests.get(url)\n        return jcamp.jcamp_readfile(response.text)\n    except IOError:\n        print(f'Unable to open file at {url}')\n        return None\n    except Exception as e: \n        print(f'Error: {e}')\n        return None\n</code></pre>"},{"location":"reading_files/#pypeakify.filereader.nearest","title":"<code>nearest(x, y, x0)</code>","text":"<p>Find the y value in y that corresponds to the nearest x value to x0.</p> <p>Useful e.g. for identifying nodes for baseline correction that exist on the spectrum.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>array</code> <p>x data.</p> required <code>y</code> <code>array</code> <p>y data.</p> required <code>x0</code> <code>float</code> <p>x value to find nearest y value for.</p> required Source code in <code>src\\pypeakify\\filereader.py</code> <pre><code>def nearest(x, y, x0):\n    '''\n    Find the y value in y that corresponds to the nearest x value to x0.\n\n    Useful e.g. for identifying nodes for baseline correction that exist on the spectrum.\n\n    Args:\n        x (np.array): x data.\n        y (np.array): y data.\n        x0 (float): x value to find nearest y value for.\n    '''\n    idx = (np.abs(x-x0)).argmin()\n    return y[idx]\n</code></pre>"},{"location":"reading_files/#pypeakify.filereader.nearest_points","title":"<code>nearest_points(x, y, x0)</code>","text":"<p>Find the y values in y that correspond to the nearest x values to x0.</p> <p>Useful e.g. for identifying nodes for baseline correction that exist on the spectrum.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>array</code> <p>x data.</p> required <code>y</code> <code>array</code> <p>y data.</p> required <code>x0</code> <code>array</code> <p>x values to find nearest y values for.</p> required Source code in <code>src\\pypeakify\\filereader.py</code> <pre><code>def nearest_points(x, y, x0):\n    '''\n    Find the y values in y that correspond to the nearest x values to x0.\n\n    Useful e.g. for identifying nodes for baseline correction that exist on the spectrum.\n\n    Args:\n        x (np.array): x data.\n        y (np.array): y data.\n        x0 (np.array): x values to find nearest y values for.\n    '''\n    return np.array([nearest(x, y, x0i) for x0i in x0])\n</code></pre>"},{"location":"reading_files/#pypeakify.filereader.normalize_data","title":"<code>normalize_data(x, y, range=None)</code>","text":"<p>Normalize y data to range [0, 1].</p> <p>If range is not None, normalize y data to range [0, 1] within the specified x range.</p> <p>x and y must have the same shape.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>array</code> <p>x data.</p> required <code>y</code> <code>array</code> <p>y data.</p> required <code>range</code> <code>tuple</code> <p>x range to normalize y data within. If None, normalize y data to range [0, 1].</p> <code>None</code> Source code in <code>src\\pypeakify\\filereader.py</code> <pre><code>def normalize_data(x, y, range=None):\n    '''\n    Normalize y data to range [0, 1].\n\n    If range is not None, normalize y data to range [0, 1] within the specified x range.\n\n    x and y must have the same shape.\n\n    Args:\n        x (np.array): x data.\n        y (np.array): y data.\n        range (tuple): x range to normalize y data within. If None, normalize y data to range [0, 1].\n    '''\n    if range is None:\n        return x, (y - np.min(y)) / (np.max(y) - np.min(y))\n    diffs1 = np.abs(x - range[0])\n    diffs2 = np.abs(x - range[1])\n    i1 = np.argmin(diffs1)\n    i2 = np.argmin(diffs2)\n    return x, (y - np.min(y[i1:i2])) / (np.max(y[i1:i2]) - np.min(y[i1:i2]))\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>PyPeakify provides a high-level interface for performing peak deconvolutions of various spectra. The primary objects used in this process are <code>Peak</code> objects, which represent individual peaks in the spectrum, and <code>Deconvolution</code> objects, which represent the optimization problem of fitting a sum of peaks to a spectrum. Additionally, <code>Baseline</code> objects can be used to represent the background signal in the spectrum, and can be passed to a <code>Deconvolution</code> object to correct the spectrum before fitting the peaks. This guide will walk through the basic usage of these objects, and provide examples of their use on actual data.</p>"},{"location":"usage/#peaks","title":"Peaks","text":"<p>When starting a deconvolution, often the user will have known information about hard or soft constraints on a peak's width, amplitude, and position, and may even have a good guess of what the true parameters are. The <code>Peak</code> object encapsulates all these things.</p> <pre><code>import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom pypeakify.peak import Peak\n\npeak = Peak('gaussian', \n          width=5, amplitude=1, position=0,\n          constrain_width=(0, np.inf), constrain_amplitude=(0, np.inf), constrain_position=(-2, 2))\n\nplt.figure()\npeak.plot(plt.gca())\nplt.show()\n</code></pre>"},{"location":"usage/#output","title":"Output","text":"<p>In the above example, we have defined a Gaussian peak with an initial width of 5, amplitude of 1, and position of 0. Additionally, we have also set optimization constraints on all three parameters. Note the use of <code>np.inf</code> to represent no upper bound on with and amplitude. The corresponding representation of no lower bound is simply <code>-np.inf</code>.</p>"},{"location":"usage/#baselines","title":"Baselines","text":"<p>Baseline correction is a pre-processing technique used to remove the background signal from a spectrum. PyPeakify provides a few options and a simple interface to apply baseline correction to a spectrum. Because <code>Baseline</code> objects are themselves simply callable objects of the form <code>baseline(x: np.ndarray) -&gt; np.ndarray</code>, custom baseline corrections can be easily defined and passed to a <code>Deconvolution</code> object.</p> <pre><code>import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom pypeakify.baseline import PiecewiseLinearBaseline\n\nx_nodes = np.arange(5)\ny_nodes = np.array([1, 2, 1, 3, 1])\nbaseline = PiecewiseLinearBaseline(x_nodes, y_nodes)\n\nx = np.linspace(-1, 5, 500)\n\nplt.figure()\nplt.scatter(x_nodes, y_nodes)\nplt.plot(x, baseline(x), c='k')\nplt.show()\n</code></pre>"},{"location":"usage/#output_1","title":"Output","text":"<p>In the above example, we have defined a piecewise linear baseline correction with 5 nodes. The baseline is defined by the points <code>(0, 1)</code>, <code>(1, 2)</code>, <code>(2, 1)</code>, <code>(3, 3)</code>, and <code>(4, 1)</code>. The baseline is then plotted over the range <code>[-1, 5]</code>. These baselines are manually specified and, once constructed, can be passed to a <code>Deconvolution</code> object.</p>"},{"location":"usage/#deconvolutions","title":"Deconvolutions","text":"<p>Once a baseline and peaks have been initialized, a <code>Deconvolution</code> object can be created to fit the peaks to the spectrum.</p> <p>When fit, a deconvolution object modifies copies of the peak objects to fit the spectrum. The original peak objects are not modified, and can be used as initial conditions for other deconvolutions. If a deconvolution object that has been fit once is refit to a different spectrum, the current state of the peaks will be used as the initial guess in the optimization problem.</p> <pre><code>import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom pypeakify.deconvolution import Deconvolution\n\n... # Load a spectrum, initialize peaks and baseline\n\ndeconv = Deconvolution([peak1, peak2, peak3], baseline)\ndeconv.fit(x, y)\n</code></pre> <p>In the above example, we have created a <code>Deconvolution</code> object with three peaks and a baseline correction object. The peaks are then fit to the spectrum defined by the arrays <code>x</code> and <code>y</code>. The <code>fit</code> method modifies the peaks in place to fit the spectrum, and the <code>Deconvolution</code> object can then be used to plot the spectrum and the fitted peaks. </p>"},{"location":"usage/#full-example","title":"Full Example","text":"<p>Let's take a look at a full working example of deconvolving the Amide I region of an FTIR spectra from a Bombyx Mori silkworm degummed silk sample.</p> <pre><code>import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom pypeakify.peak import Peak\nfrom pypeakify.baseline import PiecewiseLinearBaseline\nfrom pypeakify.deconvolution import Deconvolution\nfrom pypeakify.filereader import import_ascii_url, crop, normalize_data, nearest_points\n\nurl = 'https://raw.githubusercontent.com/yargerlab/Data/main/FTIR/2023_07_10_B_Mori_degummed_silk_1.dpt'\n\n# Load, crop, and normalize data\ncrop_range = [1580, 1720]\n\ndata = import_ascii_url(url)\ndata = crop(*data, crop_range)\nx, y = normalize_data(*data, crop_range)\n\n# Initialize peaks\np1 = Peak('gaussian', \n          width=5, amplitude=1, position=1618,\n          constrain_width=(0, np.inf), constrain_amplitude=(0, np.inf), constrain_position=(1616, 1622))\np2 = Peak('gaussian',\n            width=5, amplitude=1, position=1650,\n            constrain_width=(0, np.inf), constrain_amplitude=(0, np.inf), constrain_position=(1645, 1655))\np3 = Peak('gaussian',\n            width=5, amplitude=1, position=1698,\n            constrain_width=(0, np.inf), constrain_amplitude=(0, np.inf), constrain_position=(1697, 1699))\n\n# Create simple linear baseline\nx_nodes = np.array([x[0], x[-1]])\ny_nodes = np.array([y[0], y[-1]])\nbaseline = PiecewiseLinearBaseline(x_nodes, y_nodes)\n\n# Create deconvolution\ndeconv = Deconvolution([p1, p2, p3], baseline)\ndeconv.fit(x, y)\n\n# Plot deconvolution\nplt.figure()\n\nplt.plot(x, baseline(x), c='c', label='Baseline')\n\ndeconv.plot(plt.gca(), x, y, show_error=True)\n\nplt.legend()\nplt.show()\n</code></pre>"},{"location":"usage/#output_2","title":"Output","text":"<pre><code>Peak Type       Width    Amplitude    Position\n-----------  --------  -----------  ----------\ngaussian     15.6796      0.552349     1616\ngaussian     22.9313      0.268229     1650.96\ngaussian      5.67015     0.107615     1697\n</code></pre>"}]}